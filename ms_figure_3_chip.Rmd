---
title: "Figure 3 - ChIP"
author: "Michael Stadler, Charlotte Soneson, Merle Skribbe"
date: "`r Sys.Date()`"
output: 
    html_document:
        theme: united
        toc: true
        toc_float: true
        code_folding: hide
params:
    genomefasta: "reference/Schizosaccharomyces_pombe.ASM294v2.dna.toplevel.fa"
    gtf: "reference/Schizosaccharomyces_pombe.ASM294v2.55.gtf"
    chiptrackfile: "data/genome_browser_tracks_chipseq.csv.gz"
    peakcsv: "data/fused_peaks_filtered.csv.gz"
    peakenr: "data/fused_peaks_filtered_enrichments.csv.gz"
    peakchipfile: "data/fused_peaks_filtered_counts-external_chip.csv.gz"
    dbdtxt: "data/TF_DBD_annotation.txt"
    motifrds: "data/motifs_annotated.rds"
    txcsv: "data/promoters-1kb_tes-1kb_annotated.csv.gz"
    coordsatf1: "data/visnetwork_coords_atf1.csv"
editor_options: 
    chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = c("png", "cairo_pdf"))
```

# Parameter values

```{r params}
params
```

# Load required packages

```{r load-packages}
suppressPackageStartupMessages({
    library(circlize)
    library(ComplexHeatmap)
    library(grid)
    library(ggplot2)
    library(cowplot)
    library(Biostrings)
    library(BSgenome)
    library(GenomicRanges)
    library(rtracklayer)
    library(tibble)
    library(tidyr)
    library(tidygraph)
    library(universalmotif)
    library(parallel)
    library(colorspace)
    library(scattermore)
    library(ggupset)
    library(dplyr)
    library(viridisLite)
    library(SummarizedExperiment)
    library(S4Vectors)
    library(jsonlite)
    library(dendextend)
    library(kableExtra)
    library(forcats)
    library(igraph)
    library(ggraph)
    library(visNetwork)
    library(shiny)
})

source("params/plot_settings.R")
source("params/plottracks_function.R")

# define heatmap dimensions and font sizes
w_peaksHm <-  84 # heatmap body width (mm)
h_peaksHm <- 178 # total heatmap height (mm)
fs <- 8  # small font size
fm <- 9  # medium font size
fl <- 10 # large font size
```

# Helper functions

Here we define a few helper functions for using below:

```{r helper-functions}
# make first letter of a string lowercase
.lowercase <- function(x) {
    paste0(tolower(substr(x, 1, 1)), substr(x, 2, nchar(x)))
}

# make first letter of a string uppercase
.capitalize <- function(x) {
    paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)))
}

# for each region in `from`, calculate the distance to its nearest element in `to`
# if there are no element in `to` on the sequence of `from`, set distance to NA
calc_distance_to_nearest <- function(from, to) {
    stopifnot(exprs = {
        is(from, "GRanges")
        is(to, "GRanges")
    })
    tmp <- distanceToNearest(x = from, subject = to)
    d <- rep(NA, length(from))
    d[queryHits(tmp)] <- mcols(tmp)$distance
    return(d)
}

# create a network (directed graph) from an adjacency matrix
createNetwork <- function(adjmatrix, chippedTFs = colnames(mprom), settings = "igraph") {
    # create igraph graph object
    gr <- graph_from_adjacency_matrix(adjmatrix, mode = "directed")

    # remove singletons
    comps <- components(gr)
    too_small <- which(table(comps$membership) < 2)
    keep <- V(gr)[!(comps$membership %in% too_small)]
    gr <- induced_subgraph(gr, keep)

    # set attributes for vertices
    V(gr)$vertexclass <- ifelse(adjmatrix[cbind(names(V(gr)), names(V(gr)))] > 0,
                                "Autoregulated TF",
                                ifelse(names(V(gr)) %in% chippedTFs,
                                       "ChIP'ed TF", "Other TF"))
    if (settings == "visNetwork") {
        V(gr)$shape <- "triangle"
        V(gr)$size <- 15
        V(gr)$label.cex = 1.0
    } else if (settings == "igraph") {
        V(gr)$shape <- "circle"
    } else {
        stop("Unknown 'settings' parameter")
    }
    
    # highlight edges for reciprocal interactions
    eL <- as_edgelist(gr)
    recipr <- paste0(eL[,1], "-", eL[,2]) %in% paste0(eL[,2], "-", eL[,1]) & eL[,1] != eL[,2]
    E(gr)$weight <- ifelse(recipr, 2, 1)
    E(gr)$edgeclass <- ifelse(recipr, "Reciprocal", "Other")
    E(gr)$color <- ifelse(recipr, gplots::col2hex(main_colors[3]), gplots::col2hex(na_color))

    # return object
    return(gr)
}
```

# Read data

We start by reading all tables and objects needed for this figure.
Count tables are in addition normalized, and we also calculate
averages over replicates or all samples where needed:

```{r load-data}
# genome sequence
gnm <- readDNAStringSet(params$genomefasta)
names(gnm) <- sub(" .+$", "", names(gnm))

# `peakgr`: ChIP-seq peaks (as a GRanges object)
peakgr <- as(read.csv(params$peakcsv, row.names = 1), "GRanges")
peakgr$peaktype <- factor(peakgr$peaktype,
                          levels = c("common peaks (ubiquitous)",
                                     "common peaks (frequent)",
                                     "specific peaks"))
peakseq <- getSeq(gnm, peakgr)

# `peakenr`: peak IP-enrichments log2(IP/input)
peakenr <- as.matrix(read.csv(params$peakenr, row.names = 1))


# `chip_genome_tab`: data.frame with alignment densities in selected
#                    genomic regions for selected samples
chip_genome_tab <- read.csv(params$chiptrackfile)

# `genegr`: chromosomal ranges of genes (as GRanges object)
genegr <- rtracklayer::import(params$gtf, feature.type = "gene")

# `motifs`: data.frame with annotated motifs
motifs <- readRDS(params$motifrds)

# `txannot`: data.frame with transcript start site (TSS) and
#            transcript end site (TES) annotation
txannot <- read.csv(params$txcsv, row.names = 1)

# `dbd`: data.frame with information of transcription factors used as
#        IP-MS baits and their DNA binding domains
dbd <- read.delim(params$dbdtxt)
```

# Facts and numbers - ChIP-seq

```{r calc-numbers, class.source="fold-show", warning=FALSE}
# Percent of TF-bound gene promoters
round(100 * mean(txannot$prom.number.overlapping.highconf.peaks > 0), 0)

# Percent of TF-bound gene promoters, by gene biotype
txannot |>
    group_by(gene_biotype) |>
    summarise("Number of genes" = n(),
              "Percent promoters with TF enrichments" = round(
        100 * mean(prom.number.overlapping.highconf.peaks > 0), 0),
        .groups = "drop") |>
    knitr::kable()

# TF enrichments at promoters of TF genes
txannot |>
    filter(gene_id %in% dbd$PomBaseID) |>
    summarise("Number of TF genes" = n(),
              "Number of TF promoters with at least one enriched TF" =
                  sum(prom.number.distinct.enriched.TFs > 0),
              "Number of TF promoters with multiple enriched TFs" =
                  sum(prom.number.distinct.enriched.TFs > 1),
              "Number of TF promoters without detected TF enrichment" =
                  sum(prom.number.distinct.enriched.TFs == 0),
              "Number of TFs enriched at any promoter" = length(unique(unlist(strsplit(prom.enriched.TFs, ";")))),
              "Number of TFs enriched at any promoter (w/o zas1\U207A promoter)" = length(unique(unlist(strsplit(prom.enriched.TFs[gene_name != "zas1"], ";")))),
              "Number of TFs enriched at zas1\U207A promoter" = length(unique(unlist(strsplit(prom.enriched.TFs[gene_name == "zas1"], ";")))),
              "Number of TFs enriched at their own promoter" = sum(binds.own.promoter),
              "Number of TFs enriched at atf1\U207A promoter" = length(unique(unlist(strsplit(prom.enriched.TFs[gene_name == "atf1"], ";")))),
              "Number of TF promoters with Atf1 enrichment" = length(grep("Atf1", prom.enriched.TFs)),
              .groups = "drop") |>
    pivot_longer(cols = starts_with("Number"),
                 values_to = "Number", names_to = "Set") |>
    knitr::kable()

# Total number of identified DNA-binding motifs
nrow(motifs)

# Number of unique motifs (based on manual classification)
sum(motifs$unique_version_of_motif)

# Number of TFs for which at least one motif was identified
length(unique(motifs$tf_name))

# Number (percent) of common frequent peaks with at least on Atf1.m1 DNA-binding motif (CRE motif)
hits <- universalmotif::scan_sequences(motifs = motifs$motif[motifs$name == "Atf1.m1"],
                                       sequences = peakseq[peakgr$peaktype == "common peaks (frequent)"], 
                                       threshold = 1e-4,
                                       threshold.type = "pvalue",
                                       RC = TRUE,
                                       verbose = 0,
                                       nthreads = 1,
                                       return.granges = TRUE)
length(unique(hits$sequence.i))
round(100 * length(unique(hits$sequence.i)) / sum(peakgr$peaktype == "common peaks (frequent)"))
```

# Export peak ChIP data for use in `TFexplorer`

Starting from the peaks (`peakgr`) and ChIP enrichments in peaks (`peakenr`),
prepare and export the matrix in `json` format for use in `TFexplorer`.

```{r export-chipdata-to-json}
# average replicate ChIP enrichments
grp <- sub("_rep[12]$", "", colnames(peakenr))
peakenrExport <- do.call(cbind,
                         lapply(structure(unique(grp), names = unique(grp)),
                                function(nm) {
                                    rowMeans(peakenr[, grp == nm])
                                }))

# replace all enrichment values below 0 with 0
peakenrExport[peakenrExport < 0] <- 0

# cluster
dist_mat2 <- dist(peakenrExport, method = "euclidian")
hclust_avg2 <- hclust(dist_mat2, method = "average")
peakenrExportClustered <- peakenrExport[hclust_avg2$order, ]

# calculate extend peak coordinates and IGV position
IGVpos <- paste0(seqnames(peakgr), ":",
                 start(peakgr) - 100, "-",
                 end(peakgr) + 100)
IGVposClustered <- IGVpos[hclust_avg2$order]

# create peak position strings
peakPos <- paste0(seqnames(peakgr), ":", start(peakgr), "-", end(peakgr))
peakPosClustered <- peakPos[hclust_avg2$order]

# export peaks and enrichments as json
# ... calculate maximum enrichment value in each row
ChipMax <- apply(peakenrExportClustered, 1, max)
range(ChipMax)

# ... convert to JSON
heatmapDataChip <- toJSON(
    list(
        heatmapMatrix = peakenrExportClustered,
        TFs = colnames(peakenrExportClustered),
        peaks = rownames(peakenrExportClustered),
        peakPos = peakPosClustered,
        IGVpos = IGVposClustered,
        ChipMax = ChipMax
    ), pretty = TRUE)

# ... write into a file for TFexplorer
write(heatmapDataChip, "data/heatmapDataChIP.json")
```

# Calculate peak distances to tRNA or rRNA genes

We want to identify ChIP-seq peaks that are near a tRNA or rRNA gene. We can
obtain the coordinates of these genes from `genegr` and the coordinates of
peaks from `peakgr`, and calculate the distance between nearest peak-gene pairs
using `distanceToNearest()`. Any pair with a distance below `maxdist` will be
classified as "near" in the plots below.

Remark: Nearest distances can be `NA` in cases where for example a peak
resides on a sequence (chromosome) that does not contain any tRNA or rRNA gene,
or vice versa, such as the sequence `AB325691` (which contains gap-filling
sequence between SPBPB21E7.09 and SPBPB10D8.01 in chromosome 2) or the
mitochondrial sequence `MT`.

```{r calc-peak-dists}
# distance less than `maxdist` are defined as "near"
maxdist <- 100

# tRNA
# ... PomBase and Ensembl_Fungi annotate 196 and 183 tRNAs, respectively
#     we combine the two and obtain 198 annotated tRNAs
table(genegr$gene_biotype == "tRNA", genegr$source)
is_tRNA_pombase <- genegr$source == "PomBase" & genegr$gene_biotype == "tRNA"
is_tRNA_ensembl <- genegr$source == "Ensembl_Fungi" & genegr$gene_biotype == "tRNA"
is_tRNA <- is_tRNA_pombase | (is_tRNA_ensembl & !genegr %in% genegr[is_tRNA_pombase])
sum(is_tRNA)
# ... now we measure distances between nearest pairs
#     either from peak to nearest tRNA
dist.peak2tRNA <- calc_distance_to_nearest(from = peakgr, to = genegr[is_tRNA])
#     or from tRNA to nearest peak
dist.tRNA2peak <- calc_distance_to_nearest(from = genegr[is_tRNA], to = peakgr)

# rRNA
# ... all 36 5S_rRNA genes in our annotation stem from Ensembl_Fungi
table(genegr$gene_name == "5S_rRNA", genegr$source)
is_rRNA <- !is.na(genegr$gene_name) & genegr$gene_name == "5S_rRNA"
sum(is_rRNA)
# ... now we measure distances between nearest pairs
#     either from peak to nearest rRNA
dist.peak2rRNA <- calc_distance_to_nearest(from = peakgr, to = genegr[is_rRNA])
#     or from rRNA to nearest peak
dist.rRNA2peak <- calc_distance_to_nearest(from = genegr[is_rRNA], to = peakgr)
```

# Calculate motif similarities

We calculate the similarities between any pair of motifs using the
`compare_motifs()` function with `method = "PCC"` (Pearson correlation
coefficient). We allow for reverse-complements (`tryRC = TRUE`) and
require a minimal overlap between the two motifs of four nucleotides
(`min.overlap = 4`).

```{r calc-motif-sim}
motifsim <- compare_motifs(motifs = motifs$motif,
                           method = "PCC", tryRC = TRUE,
                           min.overlap = 4, min.mean.ic = 0.25,
                           normalise.scores = TRUE)
```

# Figure 3

## Fraction of motif genomic hits bound

For each motif, we visualize the fraction of sequence hits (sites in the genome
that score highly for the motif) which are bound by the corresponding
transcription factor (overlap with an enriched peak of that transcription
factor). Fractions are shown separately for each peak class.

```{r plot-fracBound}
#| fig.width: 8
#| fig.height: 5

pd <- motifs |>
    select(name, total_hits, starts_with("bound_hits")) |>
    mutate(frac_bound_hits_any = (bound_hits_common.peaks.ubiquitous +
               bound_hits_common.peaks.frequent + bound_hits_specific.peaks) / total_hits,
           `Common (ubiquitous)` = bound_hits_common.peaks.ubiquitous / total_hits,
           `Common (frequent)` = bound_hits_common.peaks.frequent / total_hits,
           `Specific` = bound_hits_specific.peaks / total_hits) |>
    arrange(desc(frac_bound_hits_any)) |>
    mutate(name = factor(name, levels = name)) |>
    pivot_longer(cols = c("Common (ubiquitous)", "Common (frequent)",
                          "Specific"), names_to = "peak_set", values_to = "fraction_bound") |>
    mutate(peak_set = factor(peak_set, levels = c("Common (ubiquitous)", "Common (frequent)",
                          "Specific")))

(p_fracbound <- ggplot(pd, aes(name, fraction_bound, fill = peak_set)) +
        geom_col() +
        scale_y_continuous(expand = expansion(mult = 0),
                           labels = scales::label_percent()) +
        scale_fill_manual(values = peakset_colors) +
        labs(x = element_blank(),
             y = "Percent of motif sites",
             fill = element_blank()) +
        theme_cowplot(12) +
        theme(legend.position = "inside",
              legend.position.inside = c(0.95, 0.75),
              legend.justification.inside = c(1, 1),
              axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
        guides(fill = guide_legend(ncol = 1)))
```

## Genome browser tracks of ChIP experiments for selected TFs

We want to illustrate ChIP and Input read densities for selected TFs around
their gene locus.

```{r plot-chip-genome-tracks-plot1}
#| fig.width: 5
#| fig.height: 4
#| message: false
#| warning: false

gnmtracks1 <- plottracks(df = chip_genome_tab,
                         gns = c("atf1", "pcr1", "cdc10", "thi5", "reb1", "toe3"),
                         cols = c(atf1 = main_colors[3], pcr1 = main_colors[2],
                                  cdc10 = main_colors[1], thi5 = "#66A61E",
                                  reb1 = main_colors[5], toe3 = main_colors[4]))
gnmtracks1
```

```{r plot-chip-genome-tracks-plot2}
#| fig.width: 5
#| fig.height: 7.4
#| message: false
#| warning: false

gnmtracks2 <- plottracks(df = chip_genome_tab,
                         gns = c("atf1", "pcr1", "cdc10", "thi5", "reb1", "toe3",
                                 "fkh2", "zas1", "SPCC320.03", "SPCC777.02", "prz1"),
                         cols = c(atf1 = main_colors[3], pcr1 = main_colors[2],
                                  cdc10 = main_colors[1], thi5 = "#66A61E",
                                  reb1 = main_colors[5], toe3 = main_colors[4],
                                  fkh2 = main_colors[3], zas1 = main_colors[2],
                                  prz1 = main_colors[5], `SPCC320.03` = "#66A61E",
                                  `SPCC777.02` = main_colors[1]),
                         font_size = 9)
gnmtracks2
```


## Motif similarity heatmap

The following creates a heatmap of pairwise motif similarities (`motifsim`),
hierarchically clustered and grouped into `n_split` clusters.
Specific clusters are are highlighted on the right and motifs in these clusters
are labeled.

```{r plot-motif-sim-small}
#| fig.width: 6
#| fig.height: 6

# define heatmap colors
cols <- hcl.colors(64, "viridis")

# use squared pairwise motif similarities without diagonal entries (self)
motifsim2 <- motifsim^2
diag(motifsim2) <- NA

# value range for color scale
rng <- range(motifsim2, na.rm = TRUE)

# hierarchical clustering of motifs (cut tree to produce `n_split` clusters)
motifcl <- hclust(dist(motifsim2, method = "euclidean"), method = "complete")
n_split <- 17
motifcl_num <- cutree(motifcl, k = n_split)
motifcl <- dendextend::rotate(as.dendrogram(motifcl),
                              c(motifcl_num[motifcl_num != 3],
                                motifcl_num[motifcl_num == 3]))

# prepare heatmap annotation data
#   `selMotifCol`: colors for highlighted motif clusters
#   `selMotifIndex`: row index of motifs in highlighted clusters
#   `nMotifs`: number of motifs identified per transcription factor
selMotifCol <- c("0" = bg_color, "3" = "black", "13" = "black", "16" = "black")
selMotifIndex <- which(motifcl_num[rownames(motifsim2)] %in% names(selMotifCol))
nMotifs <- unclass(table(sub("[.]m[0-9]+$", "", rownames(motifsim2))))[
    sub("[.]m[0-9]+$", "", rownames(motifsim))
]

# prepare heatmap annotations
#   `motifAnnot` for motifs (columns), top
#   `selMotifAnnot` for motif (rows), right side
motifAnnot <- HeatmapAnnotation(
    "Number of\nmotifs per TF" = nMotifs,
    col = list(
        "Number of\nmotifs per TF" = circlize::colorRamp2(
            colors = colorRampPalette(c("white", main_colors[4]))(max(nMotifs)),
            breaks = seq.int(max(nMotifs)))
    ),
    show_legend = TRUE, show_annotation_name = TRUE,
    annotation_name_side = "right",
    annotation_name_gp = gpar(fontsize = fl),
    annotation_legend_param = list(at = seq.int(max(nMotifs)),
                                   labels_gp = gpar(fontsize = fl),
                                   border = "gray10",
                                   legend_direction = "horizontal",
                                   legend_width = unit(18, "mm"),
                                   title_position = "lefttop",
                                   title_gp = gpar(fontsize = fl)))
selMotifAnnot <- rowAnnotation(
    highlight = ifelse(motifcl_num %in% names(selMotifCol),
                       as.character(motifcl_num), "0"),
    motifnames = anno_mark(which = "row", side = "right",
                           at = selMotifIndex, 
                           labels = rownames(motifsim2)[selMotifIndex],
                           labels_gp = gpar(fontsize = fl)),
    col = list(highlight = selMotifCol),
    show_legend = FALSE, show_annotation_name = FALSE)

# create main heatmap with annotations
hm4 <- Heatmap(matrix = motifsim2, name = "Motif\nsimilarity",
               col = circlize::colorRamp2(breaks = seq(rng[1], rng[2],
                                                       length.out = 64),
                                          colors = cols),
               cluster_rows = motifcl,
               show_row_dend = TRUE, row_dend_width = unit(10, "mm"),
               cluster_columns = motifcl, show_column_dend = FALSE,
               row_split = n_split, column_split = n_split,
               column_title = " ",
               row_gap = unit(0.2, "mm"), column_gap = unit(0.2, "mm"),
               show_row_names = FALSE,
               column_title_gp = gpar(fontsize = fl),
               row_title = " ",
               show_column_names = FALSE,
               top_annotation = motifAnnot,
               right_annotation = selMotifAnnot,
               heatmap_legend_param = list(
                   at = round(c(rng[1], mean(rng), rng[2]), 2),
                   labels_gp = gpar(fontsize = fl),
                   border = "gray10",
                   legend_direction = "horizontal",
                   legend_width = unit(18, "mm"),
                   title_position = "lefttop",
                   title_gp = gpar(fontsize = fl)),
               width = unit(w_peaksHm, "mm"), # heatmap body width
               height = unit(w_peaksHm, "mm")) # heatmap body height

# draw the heatmap and grab as a grid graphics `grob`
# (needed for combining figure panels)
# use defined random number seed to make clustering deterministic
set.seed(42L)
hm_motifs_small <- grid.grabExpr(
    hm4 <- draw(hm4, merge_legend = TRUE,
                heatmap_legend_side = "bottom",
                annotation_legend_side = "bottom"),
    width = w_peaksHm, height = w_peaksHm
)

plot_grid(hm_motifs_small)
```

We create the same heatmap in long format, allowing to label all rows:

```{r}
#| fig.width: 6
#| fig.height: 8

hm4_long <- Heatmap(matrix = motifsim2, name = "Motif\nsimilarity",
               col = circlize::colorRamp2(breaks = seq(rng[1], rng[2], length.out = 64),
                                          colors = cols),
               cluster_rows = motifcl,
               show_row_dend = TRUE, row_dend_width = unit(10, "mm"),
               cluster_columns = motifcl, show_column_dend = FALSE,
               row_split = n_split, column_split = n_split,
               column_title = " ",
               row_gap = unit(0.2, "mm"), column_gap = unit(0.2, "mm"),
               show_row_names = TRUE, row_names_side = "right",
               column_title_gp = gpar(fontsize = fl),
               row_title = " ",
               row_names_gp = gpar(fontsize = fs),
               show_column_names = FALSE,
               heatmap_legend_param = list(
                   at = round(c(rng[1], mean(rng), rng[2]), 2),
                   labels_gp = gpar(fontsize = fl),
                   border = "gray10",
                   legend_direction = "horizontal",
                   legend_width = unit(18, "mm"),
                   title_position = "lefttop",
                   title_gp = gpar(fontsize = fl)),
               width = unit(w_peaksHm * 0.5, "mm"), # heatmap body width
               height = unit(h_peaksHm * 1.15, "mm")) # heatmap body height

set.seed(42L)
hm_motifs_long <- grid.grabExpr(
    hm4_long <- draw(hm4_long, merge_legend = FALSE,
                     heatmap_legend_side = "bottom",
                     annotation_legend_side = "bottom"),
    width = w_peaksHm * 0.5, height = h_peaksHm * 1.15
)

plot_grid(hm_motifs_long)
```

Here is the complete list of motifs for each of the motif clusters,
in the order as they appear in the heatmap (from top to bottom):

```{r list-motif-clusters}
# get the row-order of the clustered heatmap
ro <- row_order(hm4)

# print the motif names in each cluster
motifs_in_cluster_list <- lapply(seq.int(n_split), function(i) {
    motifs_in_cluster <- rownames(motifsim2)[ro[[i]]]
    cat("Motif cluster", i, ":",
        paste(motifs_in_cluster, collapse = ", "), "\n")
    motifs_in_cluster
})
```

## Motif alignments

The following creates aligned sequence logos for the motifs in the highlighted
clusters from the motif similarity heatmap.

```{r plot-selected-motifs}
#| fig.width: 6
#| fig.height: 8

# `pL`: list of plots
pL <- list()

# for each highlighted motif cluster...
for (cl in setdiff(names(selMotifCol), c("0", "3"))) {
    # exctract the motif matrices
    selmotifs <- motifs$motif[match(rownames(motifsim2)[motifcl_num == cl], motifs$name)]
    # align and visualize as sequence logos
    pL[[cl]] <- universalmotif::view_motifs(
        motifs = selmotifs,
        method = "PCC", tryRC = TRUE,
        min.overlap = 4,
        min.mean.ic = 0.25,
        normalise.scores = TRUE,
        show.positions = FALSE,
        names.pos = "right",
        text.size = 10)
}

# for each motif row index, get the corresponding cluster
indexToClustername <- structure(rep(seq.int(n_split),
                                    lengths(row_order(hm4))),
                                names = unlist(row_order(hm4)))

# `pL2`: list of plots similar to `pL` but with added empty plots for white space 
pL2 <- rep(list(NULL), 2 * length(pL) + 1)
midx <- seq(2, length(pL2), by = 2)
pL2[midx] <- pL
relh_motifs <- c(0.4, rep(0.8, length(pL2) - 1))
relh_motifs[midx] <- lengths(
    split(selMotifIndex, motifcl_num[selMotifIndex])[
        setdiff(names(selMotifCol), c("0", "3"))
    ])

# combine the individual plots
motifs_aligned <- plot_grid(plotlist = pL2, align = "none", ncol = 1,
                            hjust = -0.1, vjust = 1.1,
                            label_size = 10,
                            rel_heights = relh_motifs)

print(motifs_aligned)
```

## TF peak overlaps from TFs in motif clusters

Create "upset" plots showing the overlap of transcription factor ChIP-seq
peaks among the factors in a highlighted motif cluster.

```{r tf-peak-overlaps}
#| fig.width: 6
#| fig.height: 8
#| warning: false

# select specific and common-frequent peaks only
levels(peakgr$peaktype) <- c("Common (ubiquitous)", # use shorter names
                             "Common (frequent)",
                             "Specific peaks")
peakgrSel <- peakgr[peakgr$peaktype %in% c("Specific peaks", "Common (frequent)")]

# `pL3`: list of individual upset plots
pL3 <- list()
# for each highlighted motif cluster...
for (cl in setdiff(names(selMotifCol), c("0", "3"))) {
    motifnms <- rownames(motifsim2)[motifcl_num == cl]
    cltfs <- unique(sub("[.]m[0-9]+$", "", motifnms))
    ovL <- as.list(mcols(peakgrSel)[, paste0("is_enr_in.", cltfs)])
    ovL <- lapply(ovL, function(i) names(peakgrSel)[i])
    names(ovL) <- sub("^is_enr_in.", "", names(ovL))
    nm <- unique(indexToClustername[as.character(which(motifcl_num == cl))])

    pd <- stack(ovL) |>
        left_join(y = data.frame(values = names(peakgr),
                                 type = peakgr$peaktype),
                  join_by(values)) |>
        group_by(values) |>
        summarise(ind = list(ind),
                  type = unique(type))
    pL3[[paste0("cluster ", nm)]] <-
        ggplot(pd, aes(x = ind, fill = type)) +
        geom_bar() +
        scale_x_upset() +
        scale_fill_manual(values = peakset_colors) +
        labs(x = element_blank(),
             y = "Number of\npeaks",
             fill = element_blank()) +
        theme_cowplot(fm) +
        theme(axis.ticks.x = element_blank(),
              legend.position = ifelse(cl == "16", "inside", "none"),
              legend.position.inside = c(0.95, 0.95),
              legend.justification.inside = c(1, 1)) +
        theme_combmatrix(combmatrix.label.text = element_text(colour = "black",
                                                              size = fm),
                         combmatrix.panel.point.size = 2.0,
                         combmatrix.panel.line.size = 0.8,
                         combmatrix.label.extra_spacing = 5,
                         combmatrix.label.make_space = TRUE,
                         combmatrix.label.width = unit(12, "mm"),
                         plot.margin = unit(c(7, 7, 1, 7), "points")) # top, right, bottom, left

}

# `pL4`: list of plots similar to `pL3` but with added empty plots for white space 
pL4 <- rep(list(NULL), 2 * length(pL) + 1)
pL4[midx] <- pL3
relh_upsets <- relh_motifs
relh_upsets[midx] <- relh_upsets[midx] + relh_upsets[midx + 1] - 0.01
relh_upsets[midx + 1] <- 0.01

# combine the individual plots
upsets_aligned <- plot_grid(plotlist = pL4, align = "hv", axis = "l", ncol = 1,
                            rel_heights = relh_upsets)
print(upsets_aligned)
```


## TF Autoregulation

We want to know which transcription factors are binding their own promoter
regions (1kb windows centered on transcription start sites) and thus are
possibly regulating their own transcription.

### Heatmap

For visualization, we classify known transcription factors (rows) into three
groups (the ones that do or do not bind their own promoter, and the ones that
were not ChIP'ed in this study) and indicate in a binary heatmap the ChIP-seq
experiments (columns) that showed enrichment at the promoter.

```{r plot-autoregulation-heatmap}
#| fig.width: 5
#| fig.height: 4

# prepare data
# ... transcription factor genes in ChIP-seq experiments (columns)
tfnms <- colnames(mcols(peakgr))[grep("^is_enr_in[.]", colnames(mcols(peakgr)))]
tfnms <- sub("^is_enr_in[.]", "", tfnms)
tfnms <- ifelse(grepl("^SP", tfnms), tfnms, .lowercase(tfnms))

# ... transcription factors in `txannot` (rows)
tfnms_all <- txannot$unique_einprot_id[match(dbd$PomBaseID, txannot$gene_id)]
tfnms_all <- tfnms_all[order(match(tfnms_all, tfnms))] # order as in `tfnms`
tx_sel <- ifelse(tfnms_all %in% txannot$gene_id,
                 match(tfnms_all, txannot$gene_id),
                 match(tfnms_all, txannot$gene_name))
stopifnot(all(!duplicated(txannot[tx_sel, "gene_id"]))) # exactly one transcript per gene

# ... transcription factors that were ChIP'ed in this study
tfnms_chip <- tfnms_all[txannot[tx_sel, "ChIP.this.study"]]

# ... create promoter binding matrix
mprom <- do.call(rbind, lapply(tx_sel, function(i) {
    tfnms_i <- strsplit(x = txannot[i, "prom.enriched.TFs"], split = ";")[[1]]
    as.numeric(tfnms %in% ifelse(grepl("^SP", tfnms_i), tfnms_i, .lowercase(tfnms_i)))
}))
dimnames(mprom) <- list(tfnms_all, tfnms)

stopifnot(all.equal(sum(txannot$binds.own.promoter),
                    sum(diag(mprom) > 0)))

diag(mprom[tfnms_chip, tfnms_chip]) <- ifelse(diag(mprom[tfnms_chip, tfnms_chip]) > 0,
                                              2, diag(mprom[tfnms_chip, tfnms_chip]))

# generate binary promoter binding heatmap
# ... label autoregulatory TFs
selLabels <- tfnms_chip[diag(mprom[tfnms_chip, tfnms_chip]) > 0]
stopifnot(all(selLabels %in% rownames(mprom)))
selLabelsPlot <- selLabels
selLabelsPlot[match("zas1", selLabels)] <- "zas1*"
rowLabels <- rowAnnotation(
    TFnames = anno_mark(which = "row", side = "right",
                        at = match(selLabels, rownames(mprom)), 
                        labels = selLabelsPlot,
                        labels_gp = gpar(fontsize = fl)))

# ... group TFs by promoter type
promtype <- factor(ifelse(txannot[tx_sel, "ChIP.this.study"],
                          ifelse(rowSums(mprom) > 0,
                                 "Bound\nTF promoters", "Non-bound\nTF promoters"),
                          "Not\nChIP'ed"),
                   levels = c("Bound\nTF promoters", "Non-bound\nTF promoters",
                              "Not\nChIP'ed"))

# ... order rows according to `promtype` and auto-regulation
is_auto <- function(nm, x = mprom) {
    d <- diag(x[match(nm, rownames(x)),
                match(nm, colnames(x))])
    !is.na(d) & d > 0
}
o <- order(c(3, 2, 1)[as.numeric(promtype)] * 100 +
               is_auto(rownames(mprom), mprom) * 20 +
               rowSums(mprom), decreasing = TRUE)
oc <- match(intersect(rownames(mprom)[o], colnames(mprom)), colnames(mprom))

# ... create main heatmap with annotations
hm5 <- Heatmap(mprom[o, oc], name = "hm5",
               col = circlize::colorRamp2(
                   breaks = seq(0, 2, length.out = 64),
                   colors = colorRampPalette(c(binary_heatmap_colors["FALSE"],
                                               main_colors[1],
                                               binary_heatmap_colors["TRUE"]))(64)),
               border = TRUE, border_gp = gpar(lwd = 0.5),
               cluster_rows = FALSE, show_row_dend = FALSE,
               cluster_columns = FALSE, show_column_dend = FALSE,
               row_split = promtype[o], row_title_gp = gpar(fontsize = fl),
               column_title = "TF ChIP-seq experiments",
               column_title_gp = gpar(fontsize = fl),
               show_row_names = FALSE, show_column_names = FALSE,
               right_annotation = rowLabels[o],
               use_raster = TRUE, show_heatmap_legend = FALSE,
               width = unit(w_peaksHm, "mm"), # heatmap body width
               height = unit(w_peaksHm, "mm"))

hm_prom <- grid.grabExpr({
        hm5 <- draw(hm5, merge_legend = TRUE,
                    heatmap_legend_side = "bottom",
                    annotation_legend_side = "bottom")
        decorate_heatmap_body("hm5", {
            grid.lines(c(mean(grepl("^Bound", promtype[match(tfnms, tfnms_all)])), 0),
                       c(0, 1), gp = gpar(lty = 2, lwd = 0.5))
        }, slice = 1)
        decorate_heatmap_body("hm5", {
            grid.lines(c(1, mean(grepl("^Bound", promtype[match(tfnms, tfnms_all)]))),
                       c(0, 1), gp = gpar(lty = 2, lwd = 0.5))
        }, slice = 2)
    },
    width = w_peaksHm, height = w_peaksHm
)
plot_grid(hm_prom)
```

### Heatmap (not showing the non-bound TF promoters)

We can also create the same heatmap, but without showing TF promoters (rows)
from the group "Non-bound TF promoters".

```{r plot-autoregulation-heatmap-without-nonbound}
#| fig.width: 5
#| fig.height: 3

# ... remove "Non-bound"
keep <- promtype[o] != "Non-bound\nTF promoters"
o2 <- o[keep]

# ... create main heatmap with annotations
hm6 <- Heatmap(mprom[o2, oc], name = "hm6",
               col = circlize::colorRamp2(
                   breaks = seq(0, 2, length.out = 64),
                   colors = colorRampPalette(c(binary_heatmap_colors["FALSE"],
                                               main_colors[1],
                                               binary_heatmap_colors["TRUE"]))(64)),
               border = TRUE, border_gp = gpar(lwd = 0.5),
               cluster_rows = FALSE, show_row_dend = FALSE,
               cluster_columns = FALSE, show_column_dend = FALSE,
               row_split = droplevels(promtype[o2]), row_title_gp = gpar(fontsize = fl),
               column_title = "TF ChIP-seq experiments",
               column_title_gp = gpar(fontsize = fl),
               show_row_names = FALSE, show_column_names = FALSE,
               right_annotation = rowLabels[o2],
               use_raster = TRUE, show_heatmap_legend = FALSE,
               width = unit(w_peaksHm, "mm"), # heatmap body width
               height = unit(w_peaksHm * mean(keep), "mm"))

# manually create a legend
hm_legend <- Legend(labels = c("TFs binding to another TF promoter",
                               "TFs binding to their own promoter"),
                    title = " ",
                    legend_gp = gpar(fill = c(main_colors[1],
                                              binary_heatmap_colors["TRUE"])))

hm_prom_bound <- grid.grabExpr({
        hm6 <- draw(hm6,
                    annotation_legend_side = "bottom",
                    annotation_legend_list = packLegend(hm_legend))
        decorate_heatmap_body("hm6", {
            grid.lines(c(mean(grepl("^Bound", promtype[match(tfnms, tfnms_all)])), 0),
                       c(0, 1), gp = gpar(lty = 2, lwd = 0.5))
        }, slice = 1)
    },
    width = w_peaksHm, height = w_peaksHm * mean(keep)
)
plot_grid(hm_prom_bound)
```

### Network

We construct a network in which the nodes represent TFs (the ones that were
ChIP'ed in this study are indicated by color), and the edges represent detected
binding events. An edge starting at a TF `A` and ending at a TF `B` means that
`A` targets the promoter of `B`.

We exclude the `untagged` experiment, TFs without targets and for the overall
network also the TFs `zas1` and `SPCC320.03`. `zas1` has
`r sum(mprom["zas1", ] > 0)` bound TFs in its promoter (likely an artifact),
and `SPCC320.03` has `r sum(mprom["SPCC320.03", ] > 0)`, and if these were
included, the network would be hard to visualize clearly.

```{r make-network}
#| fig.width: 10
#| fig.height: 8

## Create graph
## ... select TFs
to_remove <- c("zas1", "SPCC320.03", "untagged")
sel_tfs <- setdiff(unique(rownames(mprom), colnames(mprom)), to_remove)
cat("Number of TFs in network:", length(sel_tfs), "\n")

## ... create adjacency matrix (row: from TF, column: to TF promoter)
adjm <- matrix(0, nrow = length(sel_tfs), ncol = length(sel_tfs),
               dimnames = list(sel_tfs, sel_tfs))
adjm[setdiff(colnames(mprom), to_remove),
     setdiff(rownames(mprom), to_remove)] <- t(mprom[setdiff(rownames(mprom), to_remove),
                                                     setdiff(colnames(mprom), to_remove)] > 0)
gr <- createNetwork(adjm)

## Visualize
set.seed(123)
node_padding <- margin(.2, .2, .2, .2, "mm")
ggr <- ggraph(as_tbl_graph(gr), 
              layout = "igraph", algorithm = "fr") + 
    geom_edge_link(aes(start_cap = label_rect(node1.name, padding = node_padding),
                       end_cap = label_rect(node2.name, padding = node_padding),
                       color = edgeclass),
                   arrow = arrow(length = unit(2, 'mm'))) +
    geom_edge_loop(aes(start_cap = label_rect(node1.name, padding = node_padding),
                       end_cap = label_rect(node2.name, padding = node_padding)),
                   arrow = arrow(length = unit(2, 'mm'))) +  # Handle self-loops
    scale_edge_color_manual(values = c(Reciprocal = main_colors[3], 
                                       Other = gplots::col2hex(na_color)),
                            name = "") + 
    geom_node_point(size = 4, aes(fill = vertexclass, shape = vertexclass), 
                    color = "black", stroke = 0.1) + 
    scale_shape_manual(values = c("Other TF" = 21, "ChIP'ed TF" = 21,
                                  "Autoregulated TF" = 22), name = "") +
    scale_fill_manual(values = c("Other TF" = gplots::col2hex(bg_color),
                                 "ChIP'ed TF" = gplots::col2hex(main_colors[1]),
                                 "Autoregulated TF" = gplots::col2hex(binary_heatmap_colors["TRUE"])),
                      name = "") + 
    geom_node_text(aes(label = name), size = 3.5, repel = TRUE, vjust = 1.8) + 
    theme_graph(base_family = "sans", plot_margin = margin(30, 10, 40, 10)) + 
    guides(fill = guide_legend(override.aes = list(size = 4, alpha = 1))) + 
    coord_cartesian(clip = "off") 
print(ggr)
```

### Network around `Atf1`

For clearer visualization, we create a sub-network including only the
connections to and from `Atf1` (but now also including `SPCC320.03`):

```{r make-network-atf1}
#| fig.width: 5.75
#| fig.height: 6.8

## Create graph
## ... select TFs
to_remove <- c("zas1", "untagged")
sel_tfs <- setdiff(unique(rownames(mprom), colnames(mprom)), to_remove)

## ... create adjacency matrix (row: from TF, column: to TF promoter)
adjm <- matrix(0, nrow = length(sel_tfs), ncol = length(sel_tfs),
               dimnames = list(sel_tfs, sel_tfs))
adjm[setdiff(colnames(mprom), to_remove),
     setdiff(rownames(mprom), to_remove)] <- t(mprom[setdiff(rownames(mprom), to_remove),
                                                     setdiff(colnames(mprom), to_remove)] > 0)
## ... identify TFs connected to atf1
to_keep <- rownames(adjm)[adjm["atf1", ] > 0 | adjm[, "atf1"] > 0]
cat("Number of TFs in network:", length(to_keep), "\n")

## ... create adjacency matrix (row: from TF, column: to TF promoter)
adjm2 <- adjm[to_keep, to_keep]
gr2 <- createNetwork(adjm2)

## Visualize
if (file.exists(params$coordsatf1)) {
    # create graph with manually optimized coordinates
    coordsAtf1 <- read.csv(params$coordsatf1)
    coordsAtf1$y <- -coordsAtf1$y

    ggr2 <- ggraph(
        as_tbl_graph(gr2), 
        layout = as.matrix(coordsAtf1[match(names(V(gr2)), coordsAtf1$id), c("x", "y")]))
} else {
    # create graph using automated layout
    set.seed(234)
    ggr2 <- ggraph(as_tbl_graph(gr2), 
                   layout = "igraph", algorithm = "fr")

}

node_padding <- margin(.2, .2, .2, .2, "mm")
ggr2 <- ggr2 +
    geom_edge_link(aes(start_cap = label_rect(node1.name, padding = node_padding),
                       end_cap = label_rect(node2.name, padding = node_padding),
                       color = edgeclass),
                   arrow = arrow(length = unit(2, 'mm'))) +
    geom_edge_loop(aes(start_cap = label_rect(node1.name, padding = node_padding),
                       end_cap = label_rect(node2.name, padding = node_padding)),
                   arrow = arrow(length = unit(2, 'mm'))) +  # Handle self-loops
    scale_edge_color_manual(values = c(Reciprocal = main_colors[3], 
                                       Other = gplots::col2hex(na_color)),
                            name = "") + 
    geom_node_point(size = 4, aes(fill = vertexclass, shape = vertexclass), 
                    color = "black", stroke = 0.1) + 
    scale_shape_manual(values = c("Other TF" = 21, "ChIP'ed TF" = 21,
                                  "Autoregulated TF" = 22), name = "") +
    scale_fill_manual(values = c("Other TF" = gplots::col2hex(bg_color),
                                 "ChIP'ed TF" = gplots::col2hex(main_colors[1]),
                                 "Autoregulated TF" = gplots::col2hex(binary_heatmap_colors["TRUE"])),
                      name = "") + 
    geom_node_text(aes(label = name), size = 3.5, repel = TRUE, vjust = 1.8) + 
    theme_graph(base_family = "sans", plot_margin = margin(30, 10, 40, 10)) +
    theme(legend.position = "bottom") +
    guides(fill = guide_legend(override.aes = list(size = 4, alpha = 1))) + 
    coord_cartesian(clip = "off")

print(ggr2)
```

Below here is code that can be run manually and was used to manually
optimize the network display and export a csv file with node coordinates
(`r params$coordsatf1`):

```{r}
#| echo: false
#| eval: false

## Code for shiny app to generate coordinate csv file
shinyAppThresholds <- function(adjmatrix) {
    server <- function(input, output) {
        output$visnetwork <- renderVisNetwork({
            gr <- createNetwork(adjmatrix, settings = "visNetwork")
            visNetwork::visIgraph(gr)
        })
        
        # Get position info
        observeEvent(input$store_position, {
            visNetworkProxy("visnetwork") |> visGetPositions()
        })

        output$coordinates <- renderPrint({
            nodes_positions()
        })
        
        ## Format positions
        nodes_positions <- reactive({
            positions <- input$visnetwork_positions
            if (!is.null(positions)){
                nodes_positions <- do.call("rbind", lapply(positions, function(x){data.frame(x = x$x, y = x$y)}))
                nodes_positions$id <- names(positions)
                nodes_positions
            } else {
                NULL
            }
        })

        output$downloadCsv <- shiny::downloadHandler(
            filename = function() {
                "visnetwork_coords_atf1.csv"
            },
            content = function(file) {
                utils::write.table(nodes_positions(), file,
                                   row.names = FALSE, sep = ",",
                                   quote = FALSE)
            }
        )
    }
    
    ui <- fluidPage(
        visNetworkOutput("visnetwork", width = "100%", height = "1000px"),
        verbatimTextOutput("coordinates"),
        actionButton("store_position", "Store positions"),
        downloadButton("downloadCsv", "Download")
    )
    
    shinyApp(ui = ui, server = server)
}
shiny::runApp(shinyAppThresholds(adjm2))
```


## Peak types and presence of nearby ncRNAs

The following barplots show the numbers of ChIP-seq peaks that are near a
tRNA or 5S rRNA gene (top panel), or the numbers of tRNA/5S rRNA genes
that are distal or near a ChIP-seq peak (bottom panel).

```{r plot-ncRNA}
#| fig.width: 4
#| fig.height: 6

# prepare `data.frame`s with plotting data
peaktype <- factor(gsub("[()]", "", sub(" ", "\n", peakgr$peaktype)),
                   levels = c("Common\nubiquitous",
                              "Common\nfrequent",
                              "Specific\npeaks"))
sel_peaksEnr <- rowSums(as.matrix(mcols(peakgr)[, grep("^is_enr_in[.]", colnames(mcols(peakgr)))])) > 0
near_ncRNA <- factor(ifelse(!is.na(dist.peak2tRNA) & dist.peak2tRNA < maxdist,
                            "tRNA",
                            ifelse(!is.na(dist.peak2rRNA) & dist.peak2rRNA < maxdist,
                                   "5S rRNA", "none")),
                         levels = c("tRNA", "5S rRNA", "none"))
df_peaks <- data.frame(peaktype = peaktype[sel_peaksEnr],
                       near_ncRNA = near_ncRNA[sel_peaksEnr])
df_ncRNA <- data.frame(ncRNAtype = factor(
    rep(c("tRNA", "5S rRNA"), c(sum(is_tRNA), sum(is_rRNA))),
    levels = c("tRNA", "5S rRNA")),
                       near_peak = !is.na(c(dist.tRNA2peak, dist.rRNA2peak)) &
                           c(dist.tRNA2peak, dist.rRNA2peak) < maxdist)
df_ncRNA$group <- factor(paste0(df_ncRNA$ncRNAtype, " ", 
                                c("TRUE" = "near", "FALSE" = "distal")[as.character(df_ncRNA$near_peak)]),
                         levels = c("tRNA distal","tRNA near",
                                    "5S rRNA distal", "5S rRNA near"))

# generate plots
cols_ncRNA <- c("tRNA" = main_colors[5], "5S rRNA" = main_colors[3],
                "none" = bg_color)
# ... numbers of peaks near genes
p_ncRNA1 <- ggplot(df_peaks, aes(peaktype, fill = near_ncRNA)) +
    geom_bar() +
    scale_fill_manual(values = cols_ncRNA) +
    labs(x = element_blank(), y = "Number of peaks", fill = "Near ncRNA:") +
    theme_cowplot(8) +
    theme(legend.position = "inside",
          legend.position.inside = c(0.05, 0.95),
          legend.justification = c(0, 1))

# ... numbers of genes near peaks
p_ncRNA2 <- ggplot(df_ncRNA, aes(ncRNAtype, fill = group)) +
    geom_bar() +
    scale_fill_manual(values = c(`tRNA near` = cols_ncRNA[["tRNA"]],
                                 `tRNA distal` = lighten(cols_ncRNA["tRNA"], 0.2),
                                 `5S rRNA near` = cols_ncRNA[["5S rRNA"]],
                                 `5S rRNA distal` = lighten(cols_ncRNA["5S rRNA"], 0.2))) +
    labs(x = element_blank(), y = "Number of genes", fill = "Relative\npeak location:") +
    theme_cowplot(8) +
    theme(legend.position = "inside",
          legend.position.inside = c(0.95, 0.95),
          legend.justification = c(1, 1))

# ... combine the two panels
(p_ncRNA <- plot_grid(p_ncRNA1, p_ncRNA2, align = "v", nrow = 2))
```


## Put together

Assemble the panels into Figure 3:

```{r Fig3}
#| fig.width: 11.5
#| fig.height: 11.6
#| warning: false

cowplot::plot_grid(
    cowplot::plot_grid(
        cowplot::plot_grid(
            hm_prom_bound,
            cowplot::plot_grid(gnmtracks1, scale = 0.9),
            nrow = 2,
            labels = c("A", "C"),
            rel_heights = c(0.75, 1)
        ),
        ggr2,
        nrow = 1,
        labels = c("", "B")
    ),
    cowplot::plot_grid(
        hm_motifs_small,
        cowplot::plot_grid(
            motifs_aligned, upsets_aligned,
            nrow = 1, rel_widths = c(1.25, 1)),
        nrow = 1,
        labels = c("D", "E")
    ),
    nrow = 2,
    labels = c("", ""),
    rel_heights = c(1.75 * (w_peaksHm + 10), w_peaksHm + 20)
)
```


## Supplementary figure

Assemble the panels into Supplementary Figure 3:

```{r suppFig3}
#| fig.width: 8.5
#| fig.height: 12.5
#| warning: false

cowplot::plot_grid(
    cowplot::plot_grid(NULL, NULL, # space for labels
                       nrow = 1, labels = c("A", "B"),
                       rel_widths = c(1, 1)),
    cowplot::plot_grid(
        cowplot::plot_grid(gnmtracks2, NULL, ncol = 1, rel_heights = c(20, 1)),
        hm_motifs_long,
        nrow = 1
    ),
    p_fracbound,
    nrow = 3,
    labels = c("", "", "C"),
    rel_heights = c(0.3, 9.7, 5.0)
)
```



# Session info

<details>
<summary><b>
Session info
</b></summary>
```{r}
sessionInfo()
```
</details>
